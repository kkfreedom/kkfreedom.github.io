[{"content":"暗时间这本书看起来像是作者本人关于思维、学习、认知的一系列博文的汇总。作者引用了大量的心理学著作或者实验来说明问题，但是全书并没有太多晦涩的知识，读起来还是非常轻松愉悦的。 我读的过程中印象最深的是，作者经常尝试从生理或者说人类大脑进化的角度，来解释人类在思维、专注力、学习方面遇到的一些问题。比如强调人类大脑用于理性思维的半脑和情绪思维的半脑进化时间是很不同的，进而说明我们思维受习惯、情绪支配或者面对问题的「自利归因」，以及经常落入的思维捷径等等，都是因为掌管情绪思维的半脑进化时间更长，更像是我们大脑中的「硬编码」所以在思维中控制力更强。下面是我摘录的部分对我个人很有启发的阐述。希望自己能省视自己，学会理性的思维。\n谈时间利用和专注力：\n “投入时间”这个说法本身就是荒唐的，实际投入的是时间和效率的乘积”\n  “性格是这样一种自我实现和强化的陷阱：如果你是不容易专注的人，你会发现生活中处处都是分散你注意力的东西，你的思维难以在一个事情上停留半小时，于是你的时间变得琐碎，你很难在一个领域有长久的积累和深入的思考，这样的现实可能会让你感到沮丧，后者让你更加无法专心，这样的现实可能会让你感到焦虑，为了避开焦虑你又会去寻求其他的刺激，结果是恶性循环。”\n  “不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去”\n  “我们在记忆的时候将许多线索（例如当时的场景、问题的背景，甚至所处的语言环境、空间位置）一并编码进了记忆，事后能否提取出这段记忆严重取决于提取线索是否丰富、以及在回忆的时候是否重现了记忆时的线索”\n  “我们从大量的经济决策中得到一条适用范围很广的规律——经济决策可以抽象为对投入/回报比例的考量。这是知识获取阶段的抽象；而在问题求解阶段，我们遇到决策问题就可以从投入/回报这个维度上来考量，而不是没头苍蝇一样这边看着想想也对，一忽儿又觉得那个选项看看也对。如果不懂得看到问题的本质（如：经济决策），便很难利用之前推广出来的结论（如：投入/回报，风险估计等等），而是会被我们的原始大脑的一些可预期的非理性所控制（例如从众、从权威、甚至最可怕的行为陷阱——“推迟决策”），成为正常的傻瓜。”\n  “佛家说逆境是增上缘，课本说天降降大任于斯人必先苦其心智劳其筋骨…宗教里说经受磨难才能到达彼岸，说的都是同样的道理”\n 和我最近的想法有些出入，小时候看刘墉的『寻找一个苦难的天堂』，觉得苦难是步入成功的必要阶段，但是随着年龄的增加，觉得为人应该更有些豁达的态度，怀有一种万事无所谓的勇气。但是这里的描述又让我对磨难对于个人的成功产生困惑了。\n我觉得我可能理解错了所谓的寻找一个苦难的天堂了。 苦难本身并不值得歌颂，就像王小波在沉默的大多数里评价老三届时候说的。只是我们在面对磨难时，应当磨炼自己的意志，拥有豁达的态度，去隐忍、学习来对抗磨难。这样在走过磨难之后才会有成长，而非主动寻求磨难。如果只是陷入在磨难的情绪里，并没有克服它，没有成长。磨难一文不值。\n谈作者自己的学习习惯：\n “大脑的工作重心就从情绪模块转向了推理模块”\n  “学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。”\n  “这个自我以强大的情绪力量为动机，以习惯为己任，每时每刻都驱使着我们的行为。因为它掌握了“情绪”这个武器，所以我们只能时时拿它当大爷。不记得是哪位哲学家说的了，理性是感性的奴隶。那么，是不是就是说无法克服既有习惯了？以我的经验（以及观察到的别人的经验），还是可以的。第一条就是认识到习惯的改变绝不是一天两天的事情，承认它的难度。第二条就是如果你真想改掉习惯，就需要在过程中常常注意观察自己的行为，否则习惯会以一种你根本觉察不到的方式左右你的行为让你功亏一篑。有一个认知技巧也许可以缓解更改习惯过程中的不适：即把居住在内心的那个非理性自我当成你自己的孩子（你要去培养他），或者你的对手（你要去打败他）也行。总之不能当成自己，因为每个人都不想改变自己。”\n 这里有点像佛法所说的观察自己内心了。\n谈时间管理：\n “博客文章对我来说是学习和思考的副产品，我并不为写文章而写文章” 谈去除杂项：\n  “而实际上，关上一扇门，有时能够增大收益期望”\n 谈知识结构：\n “出现是为了解决什么问题），是怎么解决的，自身又引入了哪些新的问题，从而适用哪些场景”\n  “此外你还必须了解它的traps和pitfalls（缺陷和陷阱，如果不知道陷阱的存在，掉进去也不知道怎么掉的。）这些都是essential knowledge”\n 对于编程来说，学习一个新的知识（框架、语言）时，还要了解他的缺陷。\n “注意，熟悉并非指熟悉所有细节，而是那些重要的，或者无法在需要用到的时候按需查找的知识。比如上面提到的：适用场景不适用场景，编程范式，主要语言特性，缺陷和陷阱。”\n  “该知识的（体系或层次）结构是什么、本质是什么、第一原则是什么。”\n  “学习一个小领域的时候，时时把“最终能够写出一篇漂亮的Survey”放在大脑中提醒自己，就能有助于在阅读和实践的时候有意无意地整理知识的结构、本质和重点，经过整理之后的知识理解更深刻，更不容易忘记，更容易被提取。”\n 输出的重要性\n谈个人经历（其实也是讲自己思维的变化）：\n “但事前真的很难判断哪条路是最优的，我们能做到的，是把一条路走透了、走深了，只要不是一条太不靠谱的路，深入的过程中总会有很多的收获。只要不是太顽固，善于反省，总有一天也会逐渐意识到越来越靠谱的路。”\n  “如果觉得做不下去了，就硬着头皮坚持做，然后就类似于麻木了，适应了，那种望而却步的感觉会逐渐自动退去。惊人的简单，但事实就是如此，硬着头皮，过了那个情绪上最艰难的时候，也就适应了。”\n 谈思维的惯性（逃出思维的肖申克）：\n “我自己就有这样的体会，我在学习专业知识的时候经常使用 Google ，遇到知识性问题第一反应就是上 Google ，或者上 Wikipedia 。然而，在实际生活当中遇到一些生活问题的时候，往往第一时间想到的却不是 Google ，而是之前解决生活问题的时候建立起来的习惯（比如询问身边的朋友，或者干脆放一边不管）（虽然我曾经总结并告诉自己说“遇到任何知识性问题，第一时间问 Google ”），怎么会这样呢？生活问题难道不也是问题？难道不也应该联想到对待专业问题的方法——Google 之吗？可是我们的记忆系统的特点决定了不是这样的，生活问题就是生活问题，大脑会第一时间将我们之前怎样解决生活问题的方式提取出来，这个优先级要远远高于一个更一般的策略——Google，只有当没有特定策略的时候，大脑才会退而求其次寻求一般性策略。还有更生动的：有一次在豆瓣上看到某人[…]”\n 这两个例子在说习惯的力量。思维特点决定了我们通常会受到习惯性思维的控制，然而习惯性的思维（或者说基于习惯积累的思维）并不一定是最优解。要学会意识到哪些思维是基于习惯的，哪些是基于理性的更好的思维。\n “除了多多反省观察自己之外，在面对问题的时候多抽象其本质也是一个有力的办法”\n  “认知失调与自我辩护。如果我们在听到别人的道理之前已经有了一个心理上的倾向，那么即便别人给出一个有一定说服力的理由，根据认知失调理论，我们也会竭力为自己辩护；又由于世界是复杂的，所以我们几乎总是能够找到辩护的借口——“上次报纸上说一个英国老太太每天必吸一支烟，活了一百多岁呢。”\n 摈弃先入为主的思维陷阱，避免自我辩解。学会客观看待自己！\n “前提是我们必须首先了解自身”\n  “对付我们强大的习惯的最佳办法是将自己认为正确的（不管是自己经过困难或失败而领悟的，还是看到书上或听到别人说的）写下来，并常常拿出来翻看”\n ","date":"2020-09-09T00:00:00Z","image":"https://kkfreedom.github.io/p/%E6%9A%97%E6%97%B6%E9%97%B4-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cover_huf2c22cc46e5fdacb5731d18638564f13_504941_120x120_fill_q75_box_smart1.jpeg","permalink":"https://kkfreedom.github.io/p/%E6%9A%97%E6%97%B6%E9%97%B4-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"暗时间-读书笔记"},{"content":"spy 和 mock 的区别 简单理解：\n spy是partial mock，spy需要初始化，如果不手动初始化，mocktio默认调用无参构造初始化。 如果Method没有被mock, spy默认调用真实方法，mock不会，对于有返回值的spy返回真实的返回值，mock返回null. 对于spy，通常建议是用doReturn|Answer|Throw()方式打桩（stubbing），否则可能由于调用真实的方法而抛异常。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40   @Test  public void testSpy()  {  // another option to spies a real object instead of annotation  List\u0026lt;String\u0026gt; list = spy(new ArrayList\u0026lt;\u0026gt;(1));  // java.lang.IndexOutOfBoundsException  // when(list.get(0)).thenReturn(\u0026#34;three\u0026#34;);  // assertEquals(\u0026#34;three\u0026#34;, list.get(0));   // right way to mock  doReturn(\u0026#34;three\u0026#34;).when(list).get(0);  assertEquals(\u0026#34;three\u0026#34;, list.get(0));  verify(list, atLeast(1)).get(0);   // can pass, so spies is actually a copy of real instance  assertTrue(list.add(\u0026#34;one\u0026#34;));   assertEquals(\u0026#34;three\u0026#34;, list.get(0));  System.out.println(list.size()); // 1  list.forEach(System.out::println); // one  }   @Test  public void testMock()  {  List list = mock(List.class);  // below both work fine  when(list.get(0)).thenReturn(\u0026#34;three\u0026#34;);  assertEquals(\u0026#34;three\u0026#34;, list.get(0));   doReturn(\u0026#34;three\u0026#34;).when(list).get(0);  assertEquals(\u0026#34;three\u0026#34;, list.get(0));   list.add(\u0026#34;one\u0026#34;);  // assertTrue(list.add(\u0026#34;one\u0026#34;)); // java.lang.AssertionError   assertEquals(\u0026#34;three\u0026#34;, list.get(0));  System.out.println(list.size()); // 0  list.forEach(System.out::println); //  }   但是，doReturn也有缺陷，doReturn可以接任意objects，所以是No type safety, 参考\nMock一个object实际上会默认mock所有的方法 如果方法没有被打桩，有返回值的默认返回null, 返回boolean值的默认返回false，返回int/integer的默认返回0，void方法默认do nothing。\n以下例子引用自\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59   @Test  public void spy_Procession_Demo() {  Jack spyJack = spy(new Jack());  //使用spy的桩实现实际还是会调用stub的方法，只是返回了stub的值  when(spyJack.go()).thenReturn(false); // I say go go go!!  assertFalse(spyJack.go());  verify(spyJack).go();   //不会调用stub的方法  doReturn(false).when(spyJack).go();  assertFalse(spyJack.go()); // nothing print  }   @Test  public void callRealMethodTest() {  Jerry jerry = mock(Jerry.class);   doCallRealMethod().when(jerry).goHome();  doCallRealMethod().when(jerry).doSomeThingB();  // doCallRealMethod().when(jerry).returnInteger();   jerry.goHome(); // good day   assertEquals(0, jerry.returnInteger());  verify(jerry).returnInteger();  verify(jerry).doSomeThingA();  verify(jerry).doSomeThingB();  }  class Jack {  public boolean go() {  System.out.println(\u0026#34;I say go go go!!\u0026#34;);  return true;  } }  class Jerry {  public void goHome() {  doSomeThingA();  doSomeThingB();  }   // real invoke it.  public void doSomeThingB() {  System.out.println(\u0026#34;good day\u0026#34;);   }   // auto mock method by mockito  public void doSomeThingA() {  System.out.println(\u0026#34;you should not see this message.\u0026#34;);   }   public int returnInteger()  {  return 1;  } }   doAnswer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28   @Test  public void testDoAnswer()  {  Jack jack = mock(Jack.class);  doAnswer((Answer\u0026lt;String\u0026gt;) inv -\u0026gt; {  String name = inv.getArgument(0, String.class);  name += \u0026#34;_suffix\u0026#34;;  return name;  }).when(jack).rename(anyString());   String name = \u0026#34;Leo\u0026#34;;  assertEquals(name + \u0026#34;_suffix\u0026#34;, jack.rename(name));  } class Jack {  private String name;   public String rename(String name)  {  if (\u0026#34;Jack\u0026#34;.equals(name)) {  return \u0026#34;Jackson\u0026#34;;  }  return name;  }  public boolean go() {  System.out.println(\u0026#34;I say go go go!!\u0026#34;);  return true;  } }   use spy then test doAnswer, 由以下例子可以看出对于spy()，doAnswer不会调用真实方法，而thenAnswer会调用真实方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41   @Test  public void testDoAnswer()  {  Jack jack = spy(Jack.class);  doAnswer((Answer\u0026lt;String\u0026gt;) inv -\u0026gt; {  String name = inv.getArgument(0, String.class);  name += \u0026#34;_suffix\u0026#34;;  return name;  }).when(jack).rename(anyString());   String name = \u0026#34;Leo\u0026#34;;  assertEquals(name + \u0026#34;_suffix\u0026#34;, jack.rename(name)); // passed but print nothing  }   @Test  public void testDoAnswer()  {  Jack jack = spy(Jack.class);   when(jack.rename(\u0026#34;Jack\u0026#34;)).thenAnswer((Answer\u0026lt;String \u0026gt;) invocation -\u0026gt; {  String name = invocation.getArgument(0, String.class);  return name + \u0026#34;_suffix\u0026#34;;  }); // print: real invoke!!   String name = \u0026#34;Leo\u0026#34;;  assertEquals(name + \u0026#34;_suffix\u0026#34;, jack.rename(name));  // tests failed, print real invoke!! expeced: Leo_suffix Actual: Leo  }  class Jack {  private String name;   public String rename(String name)  {  System.out.println(\u0026#34;real invoke!!\u0026#34;);  if (\u0026#34;Jack\u0026#34;.equals(name)) {  return \u0026#34;Jackson\u0026#34;;  }  return name;  } }   ArgumentCaptor 使用ArgumentCaptor可以断言方法的参数\n1 2 3 4 5 6 7 8 9   @Test  public void testArgCaptor()  {  Jack jack = mock(Jack.class);  ArgumentCaptor\u0026lt;String \u0026gt; argument = ArgumentCaptor.forClass(String.class);  String rename = jack.rename(\u0026#34;Jack\u0026#34;);  verify(jack).rename(argument.capture());  assertEquals(\u0026#34;should be Jack\u0026#34;, \u0026#34;Jack\u0026#34;, argument.getValue());  }    值得注意的是，通常ArgumentCaptor使用在verfify中而不是在打桩时候，Mockito官方文档给出的例子是，如果想在打桩时候使用ArgumentMatcher更适合。  1 2 3   ArgumentCaptor\u0026lt;Person\u0026gt; argument = ArgumentCaptor.forClass(Person.class);  verify(mock).doSomething(argument.capture());  assertEquals(\u0026#34;John\u0026#34;, argument.getValue().getName());    Warning: it is recommended to use ArgumentCaptor with verification but not with stubbing. Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or \u0026rsquo;then\u0026rsquo;) block. Also it may reduce defect localization because if stubbed method was not called then no argument is captured. In a way ArgumentCaptor is related to custom argument matchers (see javadoc for ArgumentMatcher class). Both techniques can be used for making sure certain arguments were passed to mocks. However, ArgumentCaptor may be a better fit if:\n custom argument matcher is not likely to be reused you just need it to assert on argument values to complete verification Custom argument matchers via ArgumentMatcher are usually better for stubbing.   以下引用的例子用来解释为什么打桩时候使用ArgumentMatcher更适合。\n Assuming the following method to test: public boolean doSomething(SomeClass arg); Mockito documentation says that you should not use captor in this way: when(someObject.doSomething(argumentCaptor.capture())).thenReturn(true);  assertThat(argumentCaptor.getValue(), equalTo(expected)); Because you can just use matcher during stubbing: when(someObject.doSomething(eq(expected))).thenReturn(true);\n ","date":"2019-03-11T00:00:00Z","image":"https://kkfreedom.github.io/p/mockito/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://kkfreedom.github.io/p/mockito/","title":"Mockito"},{"content":"Gradle在Java开发中可以作为项目构建工具，相比于Maven，Gradle构建更加快速，没有复杂的xml文件，取而代之的是通过脚本完成诸如依赖管理，项目构建配置，插件配置等功能。 Gradle官网提供了详细的文档，Gradle Document，本文记录的是个人在学习以及使用Gradle过程中，使用到的特性以及遇到问题的解决办法。\n Gradle project结构  gradle_structure  Gradle常用命令  初始化Gradle项目gradle init    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  $ gradle init Select type of project to generate:  1: basic  2: application  3: library  4: Gradle plugin Enter selection (default: basic) [1..4] 3  Select implementation language:  1: C++  2: Groovy  3: Java  4: Kotlin  5: Scala  6: Swift Enter selection (default: Java) [1..6] 3  Select build script DSL:  1: Groovy  2: Kotlin Enter selection (default: Groovy) [1..2] 1  Select test framework:  1: JUnit 4  2: TestNG  3: Spock  4: JUnit Jupiter Enter selection (default: JUnit 4) [1..4]  Project name (default: demo): Source package (default: demo):   BUILD SUCCESSFUL 2 actionable tasks: 2 executed     构建Gradle项目 gradle build\n  如果项目中包含了warpper script，更建议使用./gradlew build\n  gradle.properties - Gradle运行环境配置 当我们想配置一些本地的环境变量或者针对gradle build做一些配置的时候，可以使用gradle.properties配置文件，下面是一些开发中的例子。\n    本地jdk环境是jdk8, 但是想让Gradle在jdk11环境下编译 在project root下添加gradle.properties文件，增加如下配置 org.gradle.java.home=/Library/Java/JavaVirtualMachines/adoptopenjdk-11.jdk/Contents/Home   gradle.properties支持多种配置方式，如果在多个地方均配置有properties文件，优先级如下：\n  system properties, e.g. when -Dgradle.user.home is set on the command line. gradle.properties in GRADLE_USER_HOME directory. gradle.properties in project root directory. gradle.properties in Gradle installation directory.   其他的关于build的详细配置，可以参考官网Build Enviroment\n build.gradle - 使用Gradle管理依赖   Gradle可以使用Maven仓库，如果想在项目中优先使用本地仓库，可以在repositories中加入mavenLocal() 当需要添加某项依赖时，首先可以去https://search.maven.org/ 或https://mvnrepository.com/检索相应的依赖包，选择想要的版本，然后复制对应的gradle路径即可，以下两种方式是等效的。 implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.14.0' implementation 'org.apache.logging.log4j:log4j-core:2.14.0'\n  repository.png \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  plugins { \tid \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.4.3\u0026#39; \tid \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39; \tid \u0026#39;java\u0026#39; }  group = \u0026#39;io.leo\u0026#39; version = \u0026#39;0.0.1-SNAPSHOT\u0026#39; sourceCompatibility = \u0026#39;11\u0026#39;  configurations { \tcompileOnly { \textendsFrom annotationProcessor \t} }  repositories { \tmavenLocal() \tmavenCentral() }  dependencies { \timplementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; \timplementation \u0026#39;org.springframework.boot:spring-boot-starter-security\u0026#39; \timplementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; \timplementation \u0026#39;com.alibaba:fastjson:1.2.75\u0026#39; \timplementation group: \u0026#39;org.apache.logging.log4j\u0026#39;, name: \u0026#39;log4j-core\u0026#39;, version: \u0026#39;2.14.0\u0026#39; \tcompileOnly \u0026#39;org.projectlombok:lombok\u0026#39; \tdevelopmentOnly \u0026#39;org.springframework.boot:spring-boot-devtools\u0026#39; \truntimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; \tannotationProcessor \u0026#39;org.springframework.boot:spring-boot-configuration-processor\u0026#39; \tannotationProcessor \u0026#39;org.projectlombok:lombok\u0026#39; \ttestImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; \ttestImplementation \u0026#39;org.springframework.security:spring-security-test\u0026#39; }  test { \tuseJUnitPlatform() }   ","date":"2019-03-09T00:00:00Z","image":"https://kkfreedom.github.io/p/gradle%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://kkfreedom.github.io/p/gradle%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/","title":"Gradle实操笔记"},{"content":"今天好好的又又又把 tcp 的三次/四次握手学习了一遍，输出一下。\n帮助理解的重要前提 这个前提就是，tcp 本身是一个面向连接的，全双工的传输层协议。也即 bi-direction or to say full-duplex。\n三次握手 借用一张网图：  image \n四次断开 再借一张图：  image \n自己总结 用自己的白话来讲就是，tcp 不管建立连接还是关闭连接，都有 sync/fin - ack 的过程，从client 和 server 出发来讲都是如此。 之所以建立连接只需要三次，是因为，当 server接到 client 的 sync 请求时，可以同时把 ack 和 sync 合并发送给 client。 而关闭连接需要四次是因为，server 接到 client 的 fin 请求并返回 ack 之后，并不一定要决定此时立刻马上也把自己关掉。 （这里就是前文提到的重要前提，因为 tcp 是全双工的，虽然你 client 不想和我连接了，但是我自己的事情还没处理完，比如server 还没接收完上次的发过来的数据等等），所以这时候并不一定会立刻返回fin 给 client，于是便有了四次握手。但是，并不一定不代表不会，猜想当 server 在收到 client 发送的 fin 之后发现自己也可以关掉连接了，于是有可能也会在返回 ack 时候同时返回 fin。这时候关闭连接实际上也是三次。 这也是我在 Stack Overflow 上看到有人问为什么 tcp 关闭连接时四次握手而不是三次握手底下看到的最简短的一个答案：It can， and sometimes it does! 😄\nPS: 网图侵删\n","date":"2019-03-08T00:00:00Z","image":"https://kkfreedom.github.io/p/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%96%AD%E5%BC%80/cover_hue960b704251fe56a5e22d487c660ab17_665080_120x120_fill_q75_box_smart1.jpg","permalink":"https://kkfreedom.github.io/p/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%96%AD%E5%BC%80/","title":"TCP的三次握手和四次断开"},{"content":"需求 在 Junit 中，有时需要为子类继承自父类的属性赋值，但是父类中的属性没有提供 setter 方法，此时可以使用反射\n 假设类之间有如下继承关系  父类-RequestBase  子类-SearchRequest     其中父类中 filter 字段未提供 setter 方法，但是在 Junit 中需要为 filter 字段设置值以验证某些场景  实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  SearchRequest request = null; Class\u0026lt;SearchRequest\u0026gt; clazz = SearchRequest.class; request = clazz.newInstance(); // 获取父类 class 对象 Class\u0026lt;? super SearchRequest\u0026gt; superclass = clazz.getSuperclass();  List\u0026lt;Filter\u0026gt; filterList = new ArrayList(); Filter filter = new BuyerFilter(); filter.setPattern(\u0026#34;*\u0026#34;); filter.setType(\u0026#34;java.lang.String\u0026#34;); filter.setSearchFieldName(\u0026#34;name\u0026#34;); filterList.add(filter); // 反射获取父类字段并赋值给子类对象 Field buyFilter = superclass.getDeclaredField(\u0026#34;filter\u0026#34;); buyFilter.setAccessible(true); buyFilter.set(request, buyerFilterList); // 子类字段直接赋值 request.setLocale(\u0026#34;en_US\u0026#34;);   ","date":"2019-03-05T00:00:00Z","image":"https://kkfreedom.github.io/p/java-%E5%8F%8D%E5%B0%84/cover_hu91c90233d97d863d69aeb06e3f7d9c8a_29651_120x120_fill_q75_box_smart1.jpeg","permalink":"https://kkfreedom.github.io/p/java-%E5%8F%8D%E5%B0%84/","title":"Java 反射"}]